from importlib import metadata

import click
from pydantic import ValidationError

from repo_agent.doc_meta_info import DocItem, MetaInfo
from repo_agent.log import logger, set_logger_level_from_config
from repo_agent.runner import Runner, delete_fake_files
from repo_agent.settings import SettingsManager
from repo_agent.utils.meta_info_utils import delete_fake_files, make_fake_files

try:
    version_number = metadata.version("repoagent")
except metadata.PackageNotFoundError:
    version_number = "0.0.0"


@click.group()
@click.version_option(version_number)
def cli():
    """An LLM-Powered Framework for Repository-level Code Documentation Generation."""
    pass


def handle_setting_error(e: ValidationError):
    """Handle configuration errors for settings."""
    # 打印通用的错误消息
    click.echo(
        click.style(
            "Configuration error detected. Please check your settings.",
            fg="red",
            bold=True,
        ),
        err=True,
        color=True,
    )

    # 输出更详细的字段缺失信息，使用颜色区分
    for error in e.errors():
        field = error["loc"][-1]
        if error["type"] == "missing":
            message = click.style(
                f"Missing required field `{field}`. Please set the `{field}` environment variable.",
                fg="yellow",
            )
        else:
            message = click.style(error["msg"], fg="yellow")
        click.echo(message, err=True, color=True)

    # 使用 ClickException 优雅地退出程序
    raise click.ClickException(
        click.style("Program terminated due to configuration errors.", fg="red")
    )


@cli.command()
def run():
    """Run the program with the specified parameters."""
    try:
        # 调用 SettingsManager.get_setting() 来获取配置
        setting = SettingsManager.get_setting()
        set_logger_level_from_config(log_level=setting.project.log_level)
    except ValidationError as e:
        handle_setting_error(e)
        return

    # 如果设置成功，则运行任务
    runner = Runner()
    runner.run()
    logger.success("Documentation task completed.")


@cli.command()
def clean():
    """Clean the fake files generated by the documentation process."""
    delete_fake_files()
    logger.success("Fake files have been cleaned up.")


@cli.command()
def print_hierarchy():
    """Print the hierarchy of the target repository."""
    try:
        # 调用 SettingsManager.get_setting() 来获取配置
        setting = SettingsManager.get_setting()
    except ValidationError as e:
        handle_setting_error(e)
        return

    runner = Runner()
    runner.meta_info.target_repo_hierarchical_tree.print_recursive()
    logger.success("Hierarchy printed.")


@cli.command()
def diff():
    """Check for changes and print which documents will be updated or generated."""
    try:
        # 调用 SettingsManager.get_setting() 来获取配置
        setting = SettingsManager.get_setting()
    except ValidationError as e:
        handle_setting_error(e)
        return

    runner = Runner()
    if runner.meta_info.in_generation_process:  # 如果不是在生成过程中，就开始检测变更
        click.echo("This command only supports pre-check")
        raise click.Abort()

    file_path_reflections, jump_files = make_fake_files()
    new_meta_info = MetaInfo.init_meta_info(file_path_reflections, jump_files)
    new_meta_info.load_doc_from_older_meta(runner.meta_info)
    delete_fake_files()

    setting = SettingsManager.get_setting()

    DocItem.check_has_task(
        new_meta_info.target_repo_hierarchical_tree,
        ignore_list=setting.project.ignore_list,
    )
    if new_meta_info.target_repo_hierarchical_tree.has_task:
        click.echo("The following docs will be generated/updated:")
        new_meta_info.target_repo_hierarchical_tree.print_recursive(
            diff_status=True, ignore_list=setting.project.ignore_list
        )
    else:
        click.echo("No docs will be generated/updated, check your source-code update")


if __name__ == "__main__":
    cli()
